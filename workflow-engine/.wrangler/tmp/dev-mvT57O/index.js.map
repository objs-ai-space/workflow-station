{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-WhCXnJ/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-WhCXnJ/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/.wrangler/tmp/dev-mvT57O",
  "sourcesContent": ["import {\n\tWorkflowEntrypoint,\n\tWorkflowEvent,\n\tWorkflowStep,\n} from \"cloudflare:workers\";\n\n// Conditional instruction structure for if-else logic\ntype ConditionalInstruction = {\n\tinstruction: string; // The instruction to execute\n\tcondition?: {\n\t\t// Evaluate condition after this step completes\n\t\tevaluateAfterStep?: number; // Step number to evaluate condition against (1-indexed)\n\t\texpression: string; // Natural language condition, e.g., \"result contains 'success'\" or \"result length is greater than 100\"\n\t\tifTrue?: number[]; // Step indices (0-indexed) to execute if condition is true\n\t\tifFalse?: number[]; // Step indices (0-indexed) to execute if condition is false\n\t\t// If neither ifTrue nor ifFalse specified, continue sequentially\n\t};\n};\n\n// Endpoint instruction structure for external API calls\ntype EndpointInstruction = {\n\ttype: \"endpoint\"; // Identifies this as an endpoint instruction\n\tendpointUrl: string; // URL of the endpoint worker (e.g., \"https://endpoint-1.your-subdomain.workers.dev\")\n\tapiUrl: string; // External API URL to call\n\tmethod?: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\"; // HTTP method (default: GET)\n\theaders?: Record<string, string>; // Custom headers\n\tbody?: any; // Request body (for POST, PUT, PATCH)\n\tretries?: number; // Number of retry attempts (default: 3)\n\tretryDelay?: number; // Delay between retries in milliseconds (default: 1000)\n\ttimeout?: number; // Request timeout in milliseconds (default: 30000)\n\tdescription?: string; // Optional description of what this endpoint does\n\tcondition?: {\n\t\t// Same conditional logic as ConditionalInstruction\n\t\tevaluateAfterStep?: number;\n\t\texpression: string;\n\t\tifTrue?: number[];\n\t\tifFalse?: number[];\n\t};\n};\n\n// Thread instruction structure for collecting results from multiple steps\n// This allows LLM to see results from multiple previous steps, not just the immediately previous one\ntype ThreadInstruction = {\n\ttype: \"thread\"; // Identifies this as a thread instruction\n\tcollectFromSteps: number[]; // Step numbers (1-indexed) to collect results from\n\toutputFormat?: \"json\" | \"markdown\" | \"numbered\"; // How to format collected results (default: json)\n\tdescription?: string; // Optional description of what this thread collects\n\tcompletionCheck?: {\n\t\t// How to determine if thread is ready to output\n\t\tmode: \"deterministic\" | \"llm\"; // deterministic: check if all steps are done; llm: use LLM to evaluate\n\t\texpression?: string; // For LLM mode: natural language condition to evaluate if collection is complete\n\t};\n\tcondition?: {\n\t\t// Same conditional logic as other instructions\n\t\tevaluateAfterStep?: number;\n\t\texpression: string;\n\t\tifTrue?: number[];\n\t\tifFalse?: number[];\n\t};\n};\n\n// Router instruction structure for LLM-driven dynamic endpoint selection\n// This allows the LLM to choose which endpoint to call based on context analysis\ntype RouterInstruction = {\n\ttype: \"router\"; // Identifies this as a router instruction\n\tdescription: string; // What this router step does\n\tevaluationPrompt: string; // Question for LLM to evaluate which option to choose\n\toptions: Array<{\n\t\tid: string; // Unique identifier for this option (e.g., \"weather\", \"news\", \"finance\")\n\t\tname: string; // Human-readable name for display\n\t\tdescription: string; // Description for LLM to understand when to pick this option\n\t\tendpoint: {\n\t\t\tendpointUrl: string; // Which endpoint worker to use\n\t\t\tapiUrl: string; // The actual API/route to call\n\t\t\tmethod?: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\"; // HTTP method\n\t\t\theaders?: Record<string, string>; // Custom headers\n\t\t\tbody?: any; // Request body for POST/PUT/PATCH\n\t\t};\n\t}>;\n\tdefaultOption?: string; // ID of option to use if LLM can't decide\n\tretries?: number; // Number of retry attempts for the selected endpoint (default: 3)\n\tretryDelay?: number; // Delay between retries in milliseconds (default: 1000)\n\ttimeout?: number; // Request timeout in milliseconds (default: 30000)\n\tcondition?: {\n\t\t// Same conditional logic as other instructions\n\t\tevaluateAfterStep?: number;\n\t\texpression: string;\n\t\tifTrue?: number[];\n\t\tifFalse?: number[];\n\t};\n};\n\n// User-defined params passed to your Workflow\ntype Params = {\n\tcontext: string; // The initial context to process\n\tinstructions: (string | ConditionalInstruction | EndpointInstruction | ThreadInstruction | RouterInstruction)[]; // Array of instructions\n\tprovider?: \"openai\" | \"anthropic\"; // AI provider (default: openai)\n\tmodel?: string; // Model name (default: gpt-5-nano for OpenAI, claude-haiku-4-5 for Anthropic)\n\t// Legacy support for backward compatibility\n\tfirstInstruction?: string;\n\tsecondInstruction?: string;\n};\n\n// Helper function to call OpenAI API - optimized for speed\nasync function callOpenAI(\n\tapiKey: string,\n\tmodel: string,\n\tsystemPrompt: string,\n\tuserPrompt: string,\n): Promise<string> {\n\t// GPT-5-nano only supports default temperature (1), not custom values\n\tconst isGPT5Nano = model.includes(\"gpt-5-nano\");\n\t\n\t// Pre-build request body for faster execution\n\tconst requestBody: {\n\t\tmodel: string;\n\t\tmessages: Array<{ role: string; content: string }>;\n\t\ttemperature?: number;\n\t} = {\n\t\tmodel,\n\t\tmessages: [\n\t\t\t{ role: \"system\", content: systemPrompt },\n\t\t\t{ role: \"user\", content: userPrompt },\n\t\t],\n\t};\n\n\t// Only include temperature for models that support it\n\tif (!isGPT5Nano) {\n\t\trequestBody.temperature = 0.7;\n\t}\n\n\t// Make API call immediately - no delays\n\tconst response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n\t\tmethod: \"POST\",\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\tAuthorization: `Bearer ${apiKey}`,\n\t\t},\n\t\tbody: JSON.stringify(requestBody),\n\t});\n\n\tif (!response.ok) {\n\t\tconst error = await response.text();\n\t\tthrow new Error(`OpenAI API error: ${response.status} - ${error}`);\n\t}\n\n\t// Parse response immediately\n\tconst data = await response.json<{\n\t\tchoices: Array<{ message: { content: string } }>;\n\t}>();\n\n\t// Return result immediately - no post-processing delays\n\treturn data.choices[0]?.message?.content || \"\";\n}\n\n// Helper function to call Anthropic API\nasync function callAnthropic(\n\tapiKey: string,\n\tmodel: string,\n\tsystemPrompt: string,\n\tuserPrompt: string,\n): Promise<string> {\n\t// Anthropic Messages API format\n\tconst requestBody = {\n\t\tmodel,\n\t\tmax_tokens: 4096,\n\t\tsystem: systemPrompt,\n\t\tmessages: [\n\t\t\t{\n\t\t\t\trole: \"user\",\n\t\t\t\tcontent: [{ type: \"text\", text: userPrompt }],\n\t\t\t},\n\t\t],\n\t};\n\n\t// Make API call immediately - no delays\n\tconst response = await fetch(\"https://api.anthropic.com/v1/messages\", {\n\t\tmethod: \"POST\",\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\"x-api-key\": apiKey,\n\t\t\t\"anthropic-version\": \"2023-06-01\",\n\t\t},\n\t\tbody: JSON.stringify(requestBody),\n\t});\n\n\tif (!response.ok) {\n\t\tconst error = await response.text();\n\t\tthrow new Error(`Anthropic API error: ${response.status} - ${error}`);\n\t}\n\n\t// Parse response immediately\n\tconst data = await response.json<{\n\t\tcontent: Array<{ type: string; text: string }>;\n\t}>();\n\n\t// Extract text from Anthropic response format\n\treturn data.content[0]?.text || \"\";\n}\n\n// Unified LLM call function that routes to the correct provider\nasync function callLLM(\n\tprovider: \"openai\" | \"anthropic\",\n\tapiKey: string,\n\tmodel: string,\n\tsystemPrompt: string,\n\tuserPrompt: string,\n): Promise<string> {\n\tif (provider === \"anthropic\") {\n\t\treturn callAnthropic(apiKey, model, systemPrompt, userPrompt);\n\t}\n\treturn callOpenAI(apiKey, model, systemPrompt, userPrompt);\n}\n\n// Evaluate a condition using LLM\nasync function evaluateCondition(\n\tprovider: \"openai\" | \"anthropic\",\n\tapiKey: string,\n\tmodel: string,\n\tconditionExpression: string,\n\tstepResult: string,\n\tstepNumber: number,\n): Promise<boolean> {\n\tconst systemPrompt = \"You are a logical evaluator. Evaluate the given condition and respond with ONLY 'true' or 'false' (lowercase, no punctuation).\";\n\tconst userPrompt = `Evaluate this condition: \"${conditionExpression}\"\n\nStep ${stepNumber} result:\n${stepResult}\n\nRespond with only 'true' or 'false'.`;\n\n\tconst response = await callLLM(provider, apiKey, model, systemPrompt, userPrompt);\n\tconst normalized = response.trim().toLowerCase();\n\t\n\t// Parse response - look for true/false\n\tif (normalized.includes(\"true\") && !normalized.includes(\"false\")) {\n\t\treturn true;\n\t}\n\tif (normalized.includes(\"false\")) {\n\t\treturn false;\n\t}\n\t\n\t// Default to false if unclear\n\tconsole.warn(`\u26A0\uFE0F Unclear condition evaluation result: \"${response}\", defaulting to false`);\n\treturn false;\n}\n\n// Call an endpoint worker to make an external API call\nasync function callEndpoint(\n\tendpointUrl: string,\n\tapiUrl: string,\n\tmethod: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" = \"GET\",\n\theaders?: Record<string, string>,\n\tbody?: any,\n\tretries: number = 3,\n\tretryDelay: number = 1000,\n\ttimeout: number = 30000,\n): Promise<string> {\n\tconst requestBody = {\n\t\turl: apiUrl,\n\t\tmethod,\n\t\theaders: headers || {},\n\t\tbody,\n\t\tretries,\n\t\tretryDelay,\n\t\ttimeout,\n\t};\n\n\tconst response = await fetch(endpointUrl, {\n\t\tmethod: \"POST\",\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t},\n\t\tbody: JSON.stringify(requestBody),\n\t});\n\n\tif (!response.ok) {\n\t\tconst error = await response.text();\n\t\tthrow new Error(`Endpoint worker error: ${response.status} - ${error}`);\n\t}\n\n\tconst result = await response.json<{\n\t\tsuccess: boolean;\n\t\tstatus: number;\n\t\tstatusText: string;\n\t\theaders: Record<string, string>;\n\t\tbody: any;\n\t\tattempts: number;\n\t\tduration: number;\n\t\terror?: string;\n\t}>();\n\n\tif (!result.success) {\n\t\tthrow new Error(\n\t\t\t`API call failed after ${result.attempts} attempts: ${result.error || result.statusText}`\n\t\t);\n\t}\n\n\t// Convert response body to string for consistency with LLM results\n\tif (typeof result.body === \"string\") {\n\t\treturn result.body;\n\t}\n\treturn JSON.stringify(result.body);\n}\n\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\n\tasync run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n\t\tconst { \n\t\t\tcontext, \n\t\t\tinstructions, \n\t\t\tprovider = \"openai\",\n\t\t\tmodel, \n\t\t\tfirstInstruction, \n\t\t\tsecondInstruction \n\t\t} = event.payload;\n\n\t\t// Determine default model based on provider\n\t\tconst defaultModel = provider === \"anthropic\" ? \"claude-haiku-4-5\" : \"gpt-5-nano\";\n\t\tconst selectedModel = model || defaultModel;\n\n\t\t// Get API key based on provider\n\t\tconst apiKey = provider === \"anthropic\" \n\t\t\t? this.env.ANTHROPIC_API_KEY \n\t\t\t: this.env.OPENAI_API_KEY;\n\n\t\tif (!apiKey) {\n\t\t\tconst keyName = provider === \"anthropic\" ? \"ANTHROPIC_API_KEY\" : \"OPENAI_API_KEY\";\n\t\t\tthrow new Error(\n\t\t\t\t`${keyName} environment variable is required. ` +\n\t\t\t\t`For local development, ensure .dev.vars file exists in the project root with ${keyName} set. ` +\n\t\t\t\t`For production, set it using: wrangler secret put ${keyName}`\n\t\t\t);\n\t\t}\n\n\t\t// Support both new format (instructions array) and legacy format (firstInstruction/secondInstruction)\n\t\tconst rawInstructions = instructions && instructions.length > 0 \n\t\t\t? instructions \n\t\t\t: (firstInstruction && secondInstruction ? [firstInstruction, secondInstruction] : []);\n\n\t\tif (rawInstructions.length === 0) {\n\t\t\tthrow new Error(\"At least one instruction is required\");\n\t\t}\n\n\t\t// Normalize instructions to a unified format\n\t\ttype NormalizedInstruction = ConditionalInstruction | EndpointInstruction | ThreadInstruction | RouterInstruction;\n\t\tconst normalizedInstructions: NormalizedInstruction[] = rawInstructions.map((inst) => {\n\t\t\tif (typeof inst === \"string\") {\n\t\t\t\treturn { instruction: inst };\n\t\t\t}\n\t\t\t// Check if it's an endpoint instruction\n\t\t\tif (typeof inst === \"object\" && inst !== null && \"type\" in inst && inst.type === \"endpoint\") {\n\t\t\t\treturn inst as EndpointInstruction;\n\t\t\t}\n\t\t\t// Check if it's a thread instruction\n\t\t\tif (typeof inst === \"object\" && inst !== null && \"type\" in inst && inst.type === \"thread\") {\n\t\t\t\treturn inst as ThreadInstruction;\n\t\t\t}\n\t\t\t// Check if it's a router instruction\n\t\t\tif (typeof inst === \"object\" && inst !== null && \"type\" in inst && inst.type === \"router\") {\n\t\t\t\treturn inst as RouterInstruction;\n\t\t\t}\n\t\t\treturn inst as ConditionalInstruction;\n\t\t});\n\n\t\t// Initialize result object with error and log tracking\n\t\tlet currentResult: {\n\t\t\toriginalContext: string;\n\t\t\tsteps: Array<{\n\t\t\t\tstepNumber: number;\n\t\t\t\tinstruction: string;\n\t\t\t\tresult: string;\n\t\t\t\tprocessedAt: string;\n\t\t\t\tduration: number; // Duration in seconds\n\t\t\t\tconditionEvaluated?: boolean; // Whether condition was evaluated\n\t\t\t\tconditionResult?: boolean; // Result of condition evaluation\n\t\t\t\tbranchTaken?: \"true\" | \"false\" | \"sequential\"; // Which branch was taken\n\t\t\t\terror?: string; // Error message if step failed\n\t\t\t\terrorType?: string; // Type of error (e.g., \"router\", \"endpoint\", \"llm\")\n\t\t\t}>;\n\t\t\tfinalizedAt: string;\n\t\t\terrors?: Array<{\n\t\t\t\tstepNumber: number;\n\t\t\t\tstepIndex: number;\n\t\t\t\terror: string;\n\t\t\t\terrorType: string;\n\t\t\t\ttimestamp: string;\n\t\t\t\tcontext?: string;\n\t\t\t}>;\n\t\t\tlogs?: Array<{\n\t\t\t\tlevel: \"info\" | \"warn\" | \"error\" | \"debug\";\n\t\t\t\tmessage: string;\n\t\t\t\ttimestamp: string;\n\t\t\t\tstepNumber?: number;\n\t\t\t\tdata?: unknown;\n\t\t\t}>;\n\t\t} = {\n\t\t\toriginalContext: context,\n\t\t\tsteps: [],\n\t\t\tfinalizedAt: \"\",\n\t\t\terrors: [],\n\t\t\tlogs: [],\n\t\t};\n\t\t\n\t\t// Helper to add log entry\n\t\tconst addLog = (level: \"info\" | \"warn\" | \"error\" | \"debug\", message: string, stepNumber?: number, data?: unknown) => {\n\t\t\tcurrentResult.logs?.push({\n\t\t\t\tlevel,\n\t\t\t\tmessage,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tstepNumber,\n\t\t\t\tdata,\n\t\t\t});\n\t\t};\n\t\t\n\t\t// Helper to add error entry\n\t\tconst addError = (stepNumber: number, stepIndex: number, error: string, errorType: string, context?: string) => {\n\t\t\tcurrentResult.errors?.push({\n\t\t\t\tstepNumber,\n\t\t\t\tstepIndex,\n\t\t\t\terror,\n\t\t\t\terrorType,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tcontext,\n\t\t\t});\n\t\t};\n\t\t\n\t\taddLog(\"info\", `Starting workflow with ${normalizedInstructions.length} instructions`, undefined, { provider, model: selectedModel });\n\n\t\t// Track which steps have been executed to avoid infinite loops\n\t\tconst executedSteps = new Set<number>();\n\t\t// Queue of step indices to execute\n\t\tconst executionQueue: number[] = [];\n\t\t\n\t\t// Build set of branch target steps (steps that are only reachable via ifTrue/ifFalse)\n\t\t// These steps should NOT auto-continue to the next step when they complete\n\t\tconst branchTargetSteps = new Set<number>();\n\t\tfor (const inst of normalizedInstructions) {\n\t\t\tif (\"condition\" in inst && inst.condition) {\n\t\t\t\tif (inst.condition.ifTrue) {\n\t\t\t\t\tinst.condition.ifTrue.forEach(idx => branchTargetSteps.add(idx));\n\t\t\t\t}\n\t\t\t\tif (inst.condition.ifFalse) {\n\t\t\t\t\tinst.condition.ifFalse.forEach(idx => branchTargetSteps.add(idx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Initialize queue with first step\n\t\texecutionQueue.push(0);\n\n\t\t// Process instructions with conditional branching support\n\t\twhile (executionQueue.length > 0) {\n\t\t\tconst stepIndex = executionQueue.shift()!;\n\t\t\t\n\t\t\t// Skip if already executed (prevents infinite loops)\n\t\t\tif (executedSteps.has(stepIndex)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Skip if out of bounds\n\t\t\tif (stepIndex < 0 || stepIndex >= normalizedInstructions.length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texecutedSteps.add(stepIndex);\n\t\t\tconst instructionConfig = normalizedInstructions[stepIndex];\n\t\t\tconst stepNumber = currentResult.steps.length + 1;\n\t\t\tconst isFirstStep = currentResult.steps.length === 0;\n\t\t\t\n\t\t\t// Get previous result immediately - no delay\n\t\t\tconst previousResult = currentResult.steps.length > 0 \n\t\t\t\t? currentResult.steps[currentResult.steps.length - 1].result \n\t\t\t\t: context;\n\n\t\t\t// Check instruction type\n\t\t\tconst isEndpointInstruction = \"type\" in instructionConfig && instructionConfig.type === \"endpoint\";\n\t\t\tconst isThreadInstruction = \"type\" in instructionConfig && instructionConfig.type === \"thread\";\n\t\t\tconst isRouterInstruction = \"type\" in instructionConfig && instructionConfig.type === \"router\";\n\t\t\t\n\t\t\tconst instructionType = isRouterInstruction ? \"router\" : isThreadInstruction ? \"thread\" : isEndpointInstruction ? \"endpoint\" : \"llm\";\n\t\t\taddLog(\"info\", `Starting step ${stepNumber} (${instructionType})`, stepNumber);\n\t\t\t\n\t\t\t// Start next step immediately after previous completes\n\t\t\tconst stepResult = await step.do(\n\t\t\t\t`process-step-${stepNumber}`,\n\t\t\t\t{\n\t\t\t\t\tretries: {\n\t\t\t\t\t\tlimit: 3,\n\t\t\t\t\t\tdelay: \"1 second\", // Reduced from 2s for faster retries\n\t\t\t\t\t\tbackoff: \"exponential\",\n\t\t\t\t\t},\n\t\t\t\t\ttimeout: \"5 minutes\",\n\t\t\t\t},\n\t\t\t\tasync () => {\n\t\t\t\t\t// Record start time for this step (inside callback for accurate timing)\n\t\t\t\t\tconst stepStartTime = Date.now();\n\n\t\t\t\t\tlet result: string;\n\t\t\t\t\tlet instruction: string;\n\n\t\t\t\t\tif (isThreadInstruction) {\n\t\t\t\t\t\t// Handle thread instruction - collect results from specified steps\n\t\t\t\t\t\tconst threadInst = instructionConfig as ThreadInstruction;\n\t\t\t\t\t\tinstruction = threadInst.description || `Collect results from steps: ${threadInst.collectFromSteps.join(\", \")}`;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Collect results from specified steps (1-indexed step numbers)\n\t\t\t\t\t\tconst collectedResults: Array<{stepNumber: number; instruction: string; result: string}> = [];\n\t\t\t\t\t\tconst missingSteps: number[] = [];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (const stepNum of threadInst.collectFromSteps) {\n\t\t\t\t\t\t\tconst stepData = currentResult.steps.find(s => s.stepNumber === stepNum);\n\t\t\t\t\t\t\tif (stepData) {\n\t\t\t\t\t\t\t\tcollectedResults.push({\n\t\t\t\t\t\t\t\t\tstepNumber: stepData.stepNumber,\n\t\t\t\t\t\t\t\t\tinstruction: stepData.instruction,\n\t\t\t\t\t\t\t\t\tresult: stepData.result,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmissingSteps.push(stepNum);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Check completion based on mode\n\t\t\t\t\t\tconst completionCheck = threadInst.completionCheck || { mode: \"deterministic\" as const };\n\t\t\t\t\t\tlet isComplete = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (completionCheck.mode === \"deterministic\") {\n\t\t\t\t\t\t\t// Deterministic: all specified steps must be complete\n\t\t\t\t\t\t\tisComplete = missingSteps.length === 0;\n\t\t\t\t\t\t} else if (completionCheck.mode === \"llm\" && completionCheck.expression) {\n\t\t\t\t\t\t\t// LLM-based: use LLM to evaluate if collection is complete\n\t\t\t\t\t\t\tconst collectionSummary = collectedResults.map(r => \n\t\t\t\t\t\t\t\t`Step ${r.stepNumber}: ${r.result.substring(0, 200)}...`\n\t\t\t\t\t\t\t).join(\"\\n\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tisComplete = await evaluateCondition(\n\t\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\t\tapiKey,\n\t\t\t\t\t\t\t\tselectedModel,\n\t\t\t\t\t\t\t\tcompletionCheck.expression,\n\t\t\t\t\t\t\t\tcollectionSummary,\n\t\t\t\t\t\t\t\tstepNumber,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!isComplete && missingSteps.length > 0) {\n\t\t\t\t\t\t\tthrow new Error(`Thread incomplete: missing results from steps ${missingSteps.join(\", \")}. ` +\n\t\t\t\t\t\t\t\t`Ensure these steps execute before this thread step.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Format collected results based on outputFormat\n\t\t\t\t\t\tconst outputFormat = threadInst.outputFormat || \"json\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (outputFormat === \"json\") {\n\t\t\t\t\t\t\tresult = JSON.stringify({\n\t\t\t\t\t\t\t\tcollectedSteps: threadInst.collectFromSteps,\n\t\t\t\t\t\t\t\tresults: collectedResults.map(r => ({\n\t\t\t\t\t\t\t\t\tstep: r.stepNumber,\n\t\t\t\t\t\t\t\t\tinstruction: r.instruction,\n\t\t\t\t\t\t\t\t\tresult: r.result,\n\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t}, null, 2);\n\t\t\t\t\t\t} else if (outputFormat === \"markdown\") {\n\t\t\t\t\t\t\tresult = collectedResults.map(r => \n\t\t\t\t\t\t\t\t`## Step ${r.stepNumber}\\n**Instruction:** ${r.instruction}\\n\\n**Result:**\\n${r.result}`\n\t\t\t\t\t\t\t).join(\"\\n\\n---\\n\\n\");\n\t\t\t\t\t\t} else if (outputFormat === \"numbered\") {\n\t\t\t\t\t\t\tresult = collectedResults.map((r, idx) => \n\t\t\t\t\t\t\t\t`${idx + 1}. [Step ${r.stepNumber}] ${r.result}`\n\t\t\t\t\t\t\t).join(\"\\n\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = JSON.stringify(collectedResults);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else if (isRouterInstruction) {\n\t\t\t\t\t\t// Handle router instruction - LLM decides which endpoint to call\n\t\t\t\t\t\tconst routerInst = instructionConfig as RouterInstruction;\n\t\t\t\t\t\tinstruction = routerInst.description || `Router: ${routerInst.evaluationPrompt}`;\n\t\t\t\t\t\t\n\t\t\t\t\t\taddLog(\"info\", `Router step started with ${routerInst.options.length} options`, stepNumber, {\n\t\t\t\t\t\t\toptions: routerInst.options.map(o => o.id),\n\t\t\t\t\t\t\tdefaultOption: routerInst.defaultOption,\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Build the options list for LLM\n\t\t\t\t\t\tconst optionsText = routerInst.options.map((opt, idx) => \n\t\t\t\t\t\t\t`${idx + 1}. ${opt.id}: ${opt.description}`\n\t\t\t\t\t\t).join(\"\\n\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Build the selection prompt\n\t\t\t\t\t\tconst selectionPrompt = `You are evaluating which data source or API to query based on the context.\n\nCONTEXT/PREVIOUS RESULT:\n${previousResult}\n\nAVAILABLE OPTIONS:\n${optionsText}\n\nTASK: ${routerInst.evaluationPrompt}\n\nIMPORTANT: Respond with ONLY the option ID (e.g., \"${routerInst.options[0]?.id || 'option1'}\"). \nDo not include any other text, explanation, or punctuation. Just the ID.`;\n\t\t\t\t\t\t\n\t\t\t\t\t\taddLog(\"debug\", \"Sending selection prompt to LLM\", stepNumber, { promptLength: selectionPrompt.length });\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Ask LLM to select an option\n\t\t\t\t\t\tlet selectedOptionId: string;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tselectedOptionId = await callLLM(\n\t\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\t\tapiKey,\n\t\t\t\t\t\t\t\tselectedModel,\n\t\t\t\t\t\t\t\t\"You are a decision-making assistant. Your job is to analyze context and select the most appropriate option. Respond with ONLY the option ID, nothing else.\",\n\t\t\t\t\t\t\t\tselectionPrompt,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\taddLog(\"info\", `LLM returned selection: \"${selectedOptionId.trim()}\"`, stepNumber);\n\t\t\t\t\t\t} catch (llmError: unknown) {\n\t\t\t\t\t\t\tconst errMsg = llmError instanceof Error ? llmError.message : String(llmError);\n\t\t\t\t\t\t\taddLog(\"error\", `LLM selection failed: ${errMsg}`, stepNumber);\n\t\t\t\t\t\t\taddError(stepNumber, stepIndex, errMsg, \"router-llm\", \"LLM failed to select option\");\n\t\t\t\t\t\t\tthrow new Error(`Router LLM selection failed: ${errMsg}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Clean up the response (trim whitespace, remove quotes if present)\n\t\t\t\t\t\tconst cleanedSelection = selectedOptionId.trim().toLowerCase().replace(/['\"]/g, '');\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Find the selected option\n\t\t\t\t\t\tlet selectedOption = routerInst.options.find(\n\t\t\t\t\t\t\topt => opt.id.toLowerCase() === cleanedSelection\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// If not found by exact match, try partial match\n\t\t\t\t\t\tif (!selectedOption) {\n\t\t\t\t\t\t\taddLog(\"warn\", `Exact match not found for \"${cleanedSelection}\", trying partial match`, stepNumber);\n\t\t\t\t\t\t\tselectedOption = routerInst.options.find(\n\t\t\t\t\t\t\t\topt => cleanedSelection.includes(opt.id.toLowerCase()) || opt.id.toLowerCase().includes(cleanedSelection)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// If still not found, use default or first option\n\t\t\t\t\t\tif (!selectedOption) {\n\t\t\t\t\t\t\taddLog(\"warn\", `No match found, falling back to default option: ${routerInst.defaultOption || 'first option'}`, stepNumber);\n\t\t\t\t\t\t\tif (routerInst.defaultOption) {\n\t\t\t\t\t\t\t\tselectedOption = routerInst.options.find(opt => opt.id === routerInst.defaultOption);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!selectedOption) {\n\t\t\t\t\t\t\t\tselectedOption = routerInst.options[0]; // Fallback to first option\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!selectedOption) {\n\t\t\t\t\t\t\tconst errMsg = `Router could not select an option. LLM returned: \"${selectedOptionId}\"`;\n\t\t\t\t\t\t\taddLog(\"error\", errMsg, stepNumber);\n\t\t\t\t\t\t\taddError(stepNumber, stepIndex, errMsg, \"router-selection\", \"No valid option could be selected\");\n\t\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\taddLog(\"info\", `Selected option: ${selectedOption.id} (${selectedOption.name})`, stepNumber, {\n\t\t\t\t\t\t\tendpoint: selectedOption.endpoint.apiUrl,\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Call the selected endpoint\n\t\t\t\t\t\tlet endpointResult: string;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst apiUrl = selectedOption.endpoint.apiUrl;\n\t\t\t\t\t\t\tconst endpointUrl = selectedOption.endpoint.endpointUrl;\n\t\t\t\t\t\t\tconst method = selectedOption.endpoint.method || \"GET\";\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Check if this is a mock endpoint (apiUrl contains /mock/ path on the endpoint worker)\n\t\t\t\t\t\t\t// Mock endpoints should be called directly to avoid Cloudflare subrequest limitations\n\t\t\t\t\t\t\tconst isMockEndpoint = apiUrl.includes(\"/mock/\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (isMockEndpoint) {\n\t\t\t\t\t\t\t\taddLog(\"info\", `Calling mock endpoint directly: ${apiUrl}`, stepNumber);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Call mock endpoint directly\n\t\t\t\t\t\t\t\tconst controller = new AbortController();\n\t\t\t\t\t\t\t\tconst timeoutId = setTimeout(() => controller.abort(), routerInst.timeout || 30000);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\t\t\t\t\t...selectedOption.endpoint.headers,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsignal: controller.signal,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (selectedOption.endpoint.body && [\"POST\", \"PUT\", \"PATCH\"].includes(method)) {\n\t\t\t\t\t\t\t\t\tfetchOptions.body = typeof selectedOption.endpoint.body === \"string\" \n\t\t\t\t\t\t\t\t\t\t? selectedOption.endpoint.body \n\t\t\t\t\t\t\t\t\t\t: JSON.stringify(selectedOption.endpoint.body);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tconst response = await fetch(apiUrl, fetchOptions);\n\t\t\t\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (!response.ok) {\n\t\t\t\t\t\t\t\t\tthrow new Error(`Mock endpoint returned ${response.status}: ${response.statusText}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tconst responseData = await response.json();\n\t\t\t\t\t\t\t\tendpointResult = JSON.stringify(responseData);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use proxy for external APIs\n\t\t\t\t\t\t\t\tendpointResult = await callEndpoint(\n\t\t\t\t\t\t\t\t\tendpointUrl,\n\t\t\t\t\t\t\t\t\tapiUrl,\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tselectedOption.endpoint.headers,\n\t\t\t\t\t\t\t\t\tselectedOption.endpoint.body,\n\t\t\t\t\t\t\t\t\trouterInst.retries || 3,\n\t\t\t\t\t\t\t\t\trouterInst.retryDelay || 1000,\n\t\t\t\t\t\t\t\t\trouterInst.timeout || 30000,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taddLog(\"info\", `Endpoint call successful for ${selectedOption.id}`, stepNumber);\n\t\t\t\t\t\t} catch (endpointError: unknown) {\n\t\t\t\t\t\t\tconst errMsg = endpointError instanceof Error ? endpointError.message : String(endpointError);\n\t\t\t\t\t\t\taddLog(\"error\", `Endpoint call failed: ${errMsg}`, stepNumber, {\n\t\t\t\t\t\t\t\tendpoint: selectedOption.endpoint.apiUrl,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\taddError(stepNumber, stepIndex, errMsg, \"router-endpoint\", `Endpoint ${selectedOption.endpoint.apiUrl} failed`);\n\t\t\t\t\t\t\tthrow new Error(`Router endpoint call failed: ${errMsg}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Format the result to include which option was selected\n\t\t\t\t\t\tresult = JSON.stringify({\n\t\t\t\t\t\t\trouterDecision: {\n\t\t\t\t\t\t\t\tselectedOption: selectedOption.id,\n\t\t\t\t\t\t\t\tselectedName: selectedOption.name,\n\t\t\t\t\t\t\t\tllmResponse: selectedOptionId.trim(),\n\t\t\t\t\t\t\t\tendpoint: selectedOption.endpoint.apiUrl,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdata: JSON.parse(endpointResult),\n\t\t\t\t\t\t}, null, 2);\n\t\t\t\t\t\t\n\t\t\t\t\t} else if (isEndpointInstruction) {\n\t\t\t\t\t\t// Handle endpoint instruction\n\t\t\t\t\t\tconst endpointInst = instructionConfig as EndpointInstruction;\n\t\t\t\t\t\tinstruction = endpointInst.description || `Call ${endpointInst.apiUrl}`;\n\t\t\t\t\t\t\n\t\t\t\t\t\taddLog(\"info\", `Endpoint step calling ${endpointInst.apiUrl}`, stepNumber, {\n\t\t\t\t\t\t\tmethod: endpointInst.method || \"GET\",\n\t\t\t\t\t\t\tretries: endpointInst.retries || 3,\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Call endpoint worker\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresult = await callEndpoint(\n\t\t\t\t\t\t\t\tendpointInst.endpointUrl,\n\t\t\t\t\t\t\t\tendpointInst.apiUrl,\n\t\t\t\t\t\t\t\tendpointInst.method || \"GET\",\n\t\t\t\t\t\t\t\tendpointInst.headers,\n\t\t\t\t\t\t\t\tendpointInst.body,\n\t\t\t\t\t\t\t\tendpointInst.retries || 3,\n\t\t\t\t\t\t\t\tendpointInst.retryDelay || 1000,\n\t\t\t\t\t\t\t\tendpointInst.timeout || 30000,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\taddLog(\"info\", `Endpoint call successful`, stepNumber);\n\t\t\t\t\t\t} catch (endpointError: unknown) {\n\t\t\t\t\t\t\tconst errMsg = endpointError instanceof Error ? endpointError.message : String(endpointError);\n\t\t\t\t\t\t\taddLog(\"error\", `Endpoint call failed: ${errMsg}`, stepNumber);\n\t\t\t\t\t\t\taddError(stepNumber, stepIndex, errMsg, \"endpoint\", `Endpoint ${endpointInst.apiUrl} failed`);\n\t\t\t\t\t\t\tthrow endpointError;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Handle LLM instruction\n\t\t\t\t\t\tconst llmInst = instructionConfig as ConditionalInstruction;\n\t\t\t\t\t\tinstruction = llmInst.instruction;\n\n\t\t\t\t\t\t// Pre-compute prompts for faster execution\n\t\t\t\t\t\tconst systemPrompt = isFirstStep\n\t\t\t\t\t\t\t? \"You are a helpful assistant that processes and analyzes content.\"\n\t\t\t\t\t\t\t: \"You are a helpful assistant that processes and refines content based on previous results.\";\n\n\t\t\t\t\t\tconst userPrompt = isFirstStep\n\t\t\t\t\t\t\t? `${instruction}\\n\\nContext:\\n${previousResult}`\n\t\t\t\t\t\t\t: `${instruction}\\n\\nPrevious Result:\\n${previousResult}`;\n\n\t\t\t\t\t\t// Call LLM API immediately - no delays (routes to OpenAI or Anthropic)\n\t\t\t\t\t\tresult = await callLLM(provider, apiKey, selectedModel, systemPrompt, userPrompt);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Calculate duration (time spent in this step)\n\t\t\t\t\tconst stepEndTime = Date.now();\n\t\t\t\t\tconst duration = (stepEndTime - stepStartTime) / 1000; // Convert to seconds\n\n\t\t\t\t\t// Return immediately - step.do will store this and make it available for next step\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstepNumber,\n\t\t\t\t\t\tinstruction,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\tprocessedAt: new Date().toISOString(),\n\t\t\t\t\t\tduration,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t);\n\n\t\t\t// Evaluate condition if present (works for both LLM and endpoint instructions)\n\t\t\tlet conditionResult: boolean | undefined;\n\t\t\tlet branchTaken: \"true\" | \"false\" | \"sequential\" = \"sequential\";\n\t\t\t\n\t\t\tif (\"condition\" in instructionConfig && instructionConfig.condition) {\n\t\t\t\tconst condition = instructionConfig.condition;\n\t\t\t\t\n\t\t\t\t// Determine which step result to evaluate against\n\t\t\t\t// If evaluateAfterStep is specified, use that step's result; otherwise use current step\n\t\t\t\tlet resultToEvaluate: string;\n\t\t\t\tlet stepNumberToEvaluate: number;\n\t\t\t\t\n\t\t\t\tif (condition.evaluateAfterStep !== undefined) {\n\t\t\t\t\t// Find the step result to evaluate against (1-indexed step number)\n\t\t\t\t\tconst stepToEvaluate = currentResult.steps.find(s => s.stepNumber === condition.evaluateAfterStep);\n\t\t\t\t\tif (!stepToEvaluate) {\n\t\t\t\t\t\tthrow new Error(`Cannot evaluate condition: step ${condition.evaluateAfterStep} not found`);\n\t\t\t\t\t}\n\t\t\t\t\tresultToEvaluate = stepToEvaluate.result;\n\t\t\t\t\tstepNumberToEvaluate = condition.evaluateAfterStep;\n\t\t\t\t} else {\n\t\t\t\t\t// Default: evaluate against current step result\n\t\t\t\t\tresultToEvaluate = stepResult.result;\n\t\t\t\t\tstepNumberToEvaluate = stepNumber;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Evaluate condition using LLM\n\t\t\t\tconditionResult = await step.do(\n\t\t\t\t\t`evaluate-condition-${stepNumber}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tretries: {\n\t\t\t\t\t\t\tlimit: 2,\n\t\t\t\t\t\t\tdelay: \"1 second\",\n\t\t\t\t\t\t\tbackoff: \"exponential\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttimeout: \"2 minutes\",\n\t\t\t\t\t},\n\t\t\t\t\tasync () => {\n\t\t\t\t\t\treturn await evaluateCondition(\n\t\t\t\t\t\t\tprovider,\n\t\t\t\t\t\t\tapiKey,\n\t\t\t\t\t\t\tselectedModel,\n\t\t\t\t\t\t\tcondition.expression,\n\t\t\t\t\t\t\tresultToEvaluate,\n\t\t\t\t\t\t\tstepNumberToEvaluate,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\t// Determine which branch to take\n\t\t\t\tif (conditionResult) {\n\t\t\t\t\tbranchTaken = \"true\";\n\t\t\t\t\t// Add true path steps to queue\n\t\t\t\t\tif (condition.ifTrue && condition.ifTrue.length > 0) {\n\t\t\t\t\t\texecutionQueue.push(...condition.ifTrue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If no true path specified, continue sequentially\n\t\t\t\t\t\tif (stepIndex + 1 < normalizedInstructions.length) {\n\t\t\t\t\t\t\texecutionQueue.push(stepIndex + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbranchTaken = \"false\";\n\t\t\t\t\t// Add false path steps to queue\n\t\t\t\t\tif (condition.ifFalse && condition.ifFalse.length > 0) {\n\t\t\t\t\t\texecutionQueue.push(...condition.ifFalse);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If no false path specified, continue sequentially\n\t\t\t\t\t\tif (stepIndex + 1 < normalizedInstructions.length) {\n\t\t\t\t\t\t\texecutionQueue.push(stepIndex + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No condition - continue sequentially ONLY if this step is NOT a branch target\n\t\t\t\t// Branch target steps (those in ifTrue/ifFalse) should terminate their branch\n\t\t\t\tif (!branchTargetSteps.has(stepIndex) && stepIndex + 1 < normalizedInstructions.length) {\n\t\t\t\t\texecutionQueue.push(stepIndex + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Store result with condition metadata\n\t\t\tcurrentResult.steps.push({\n\t\t\t\t...stepResult,\n\t\t\t\tconditionEvaluated: \"condition\" in instructionConfig && instructionConfig.condition !== undefined,\n\t\t\t\tconditionResult,\n\t\t\t\tbranchTaken,\n\t\t\t});\n\t\t}\n\n\t\t// Mark as finalized\n\t\tcurrentResult.finalizedAt = new Date().toISOString();\n\n\t\t// Return the final result\n\t\treturn currentResult;\n\t}\n}\nexport default {\n\tasync fetch(req: Request, env: Env): Promise<Response> {\n\t\tconst url = new URL(req.url);\n\n\t\t// Handle CORS preflight\n\t\tif (req.method === \"OPTIONS\") {\n\t\t\treturn new Response(null, {\n\t\t\t\theaders: {\n\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n\t\t\t\t\t\"Access-Control-Allow-Headers\": \"Content-Type\",\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (url.pathname.startsWith(\"/favicon\")) {\n\t\t\treturn Response.json({}, { status: 404 });\n\t\t}\n\n\t\t// Get the status of an existing instance\n\t\t// GET /?instanceId=<id here>\n\t\tconst instanceId = url.searchParams.get(\"instanceId\");\n\t\tif (instanceId) {\n\t\t\ttry {\n\t\t\t\tconst instance = await env.MY_WORKFLOW.get(instanceId);\n\t\t\t\tconst status = await instance.status();\n\t\t\t\treturn Response.json(\n\t\t\t\t\t{\n\t\t\t\t\t\tinstanceId,\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\treturn Response.json(\n\t\t\t\t\t{ error: `Instance not found: ${instanceId}` },\n\t\t\t\t\t{ status: 404 },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// POST /batch - Create multiple workflow instances concurrently\n\t\tif (url.pathname === \"/batch\" && req.method === \"POST\") {\n\t\t\ttry {\n\t\t\t\tconst body = await req.json<{\n\t\t\t\t\tcount: number;\n\t\t\t\t\tcontext: string;\n\t\t\t\t\tinstructions: string[] | ConditionalInstruction[];\n\t\t\t\t\tprovider?: \"openai\" | \"anthropic\";\n\t\t\t\t\tmodel?: string;\n\t\t\t\t}>();\n\n\t\t\t\tif (!body.context) {\n\t\t\t\t\treturn Response.json(\n\t\t\t\t\t\t{ error: \"Missing required field: context\" },\n\t\t\t\t\t\t{ status: 400 },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!body.count || body.count < 1 || body.count > 20) {\n\t\t\t\t\treturn Response.json(\n\t\t\t\t\t\t{ error: \"Count must be between 1 and 20\" },\n\t\t\t\t\t\t{ status: 400 },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst hasInstructions = body.instructions && Array.isArray(body.instructions) && body.instructions.length > 0;\n\t\t\t\tif (!hasInstructions) {\n\t\t\t\t\treturn Response.json(\n\t\t\t\t\t\t{ error: \"Missing required field: instructions\" },\n\t\t\t\t\t\t{ status: 400 },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Create multiple workflow instances concurrently\n\t\t\t\tconst instances = await Promise.all(\n\t\t\t\t\tArray.from({ length: body.count }, () =>\n\t\t\t\t\t\tenv.MY_WORKFLOW.create({\n\t\t\t\t\t\t\tparams: {\n\t\t\t\t\t\t\t\tcontext: body.context,\n\t\t\t\t\t\t\t\tinstructions: body.instructions,\n\t\t\t\t\t\t\t\tprovider: body.provider || \"openai\",\n\t\t\t\t\t\t\t\tmodel: body.model || undefined,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\tconst results = await Promise.all(\n\t\t\t\t\tinstances.map(async (instance) => {\n\t\t\t\t\t\tconst status = await instance.status();\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tinstanceId: instance.id,\n\t\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t};\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\treturn Response.json(\n\t\t\t\t\t{\n\t\t\t\t\t\tcount: results.length,\n\t\t\t\t\t\tinstances: results,\n\t\t\t\t\t\tmessage: `Successfully created ${results.length} workflow instance(s)`,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\treturn Response.json(\n\t\t\t\t\t{\n\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Failed to create batch workflows\",\n\t\t\t\t\t},\n\t\t\t\t\t{ status: 500 },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// POST / - Create a new workflow instance with context and instructions\n\t\tif (req.method === \"POST\") {\n\t\t\ttry {\n\t\t\t\tconst body = await req.json<Params>();\n\n\t\t\t\t// Validate required fields\n\t\t\t\tif (!body.context) {\n\t\t\t\t\treturn Response.json(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror: \"Missing required field: context\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ status: 400 },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Support both new format (instructions array) and legacy format\n\t\t\t\tconst hasInstructions = body.instructions && Array.isArray(body.instructions) && body.instructions.length > 0;\n\t\t\t\tconst hasLegacyInstructions = body.firstInstruction && body.secondInstruction;\n\n\t\t\t\tif (!hasInstructions && !hasLegacyInstructions) {\n\t\t\t\t\treturn Response.json(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror: \"Missing required fields: either 'instructions' array or 'firstInstruction' and 'secondInstruction'\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ status: 400 },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Validate conditional instructions if provided\n\t\t\t\tif (hasInstructions && body.instructions.length > 0) {\n\t\t\t\t\tfor (let i = 0; i < body.instructions.length; i++) {\n\t\t\t\t\t\tconst inst = body.instructions[i];\n\t\t\t\t\t\tif (typeof inst === \"object\" && inst !== null && \"condition\" in inst) {\n\t\t\t\t\t\t\tconst cond = (inst as any).condition;\n\t\t\t\t\t\t\tif (cond && cond.ifTrue) {\n\t\t\t\t\t\t\t\tfor (const idx of cond.ifTrue) {\n\t\t\t\t\t\t\t\t\tif (idx < 0 || idx >= body.instructions.length) {\n\t\t\t\t\t\t\t\t\t\treturn Response.json(\n\t\t\t\t\t\t\t\t\t\t\t{ error: `Conditional instruction ${i}: ifTrue index ${idx} is out of bounds` },\n\t\t\t\t\t\t\t\t\t\t\t{ status: 400 },\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cond && cond.ifFalse) {\n\t\t\t\t\t\t\t\tfor (const idx of cond.ifFalse) {\n\t\t\t\t\t\t\t\t\tif (idx < 0 || idx >= body.instructions.length) {\n\t\t\t\t\t\t\t\t\t\treturn Response.json(\n\t\t\t\t\t\t\t\t\t\t\t{ error: `Conditional instruction ${i}: ifFalse index ${idx} is out of bounds` },\n\t\t\t\t\t\t\t\t\t\t\t{ status: 400 },\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create workflow instance with params\n\t\t\t\tconst instance = await env.MY_WORKFLOW.create({\n\t\t\t\t\tparams: {\n\t\t\t\t\t\tcontext: body.context,\n\t\t\t\t\t\tinstructions: body.instructions || undefined,\n\t\t\t\t\t\tprovider: body.provider || \"openai\",\n\t\t\t\t\t\tmodel: body.model || undefined, // Will use default based on provider\n\t\t\t\t\t\tfirstInstruction: body.firstInstruction,\n\t\t\t\t\t\tsecondInstruction: body.secondInstruction,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tconst status = await instance.status();\n\n\t\t\t\treturn Response.json(\n\t\t\t\t\t{\n\t\t\t\t\t\tinstanceId: instance.id,\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\tmessage: \"Workflow started successfully\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\treturn Response.json(\n\t\t\t\t\t{\n\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Failed to create workflow\",\n\t\t\t\t\t},\n\t\t\t\t\t{ status: 500 },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// GET / - Show usage instructions\n\t\treturn Response.json(\n\t\t\t{\n\t\t\t\tmessage: \"Multi-Provider LLM Workflow API with External Endpoint & Thread Support\",\n\t\t\t\tendpoints: {\n\t\t\t\t\t\"POST /\": {\n\t\t\t\t\t\tdescription: \"Create a new workflow instance\",\n\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\tcontext: \"string - The initial context to process\",\n\t\t\t\t\t\t\tinstructions: \"string[] | ConditionalInstruction[] | EndpointInstruction[] | ThreadInstruction[] - Array of instructions\",\n\t\t\t\t\t\t\tprovider: \"string (optional) - AI provider: 'openai' or 'anthropic' (default: 'openai')\",\n\t\t\t\t\t\t\tmodel: \"string (optional) - Model name (default: 'gpt-5-nano' for OpenAI, 'claude-haiku-4-5' for Anthropic)\",\n\t\t\t\t\t\t\tfirstInstruction: \"string (legacy) - Instruction for the first LLM call\",\n\t\t\t\t\t\t\tsecondInstruction: \"string (legacy) - Instruction for the second LLM call\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tthreadExample: {\n\t\t\t\t\t\t\tdescription: \"Thread instruction collects results from multiple steps for LLM to see all at once\",\n\t\t\t\t\t\t\tcontext: \"Gather data from multiple sources and analyze together\",\n\t\t\t\t\t\t\tinstructions: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype: \"endpoint\",\n\t\t\t\t\t\t\t\t\tendpointUrl: \"https://endpoint-1.workers.dev\",\n\t\t\t\t\t\t\t\t\tapiUrl: \"https://api.example.com/users\",\n\t\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\t\tdescription: \"Fetch users data\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype: \"endpoint\",\n\t\t\t\t\t\t\t\t\tendpointUrl: \"https://endpoint-2.workers.dev\",\n\t\t\t\t\t\t\t\t\tapiUrl: \"https://api.example.com/products\",\n\t\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\t\tdescription: \"Fetch products data\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype: \"endpoint\",\n\t\t\t\t\t\t\t\t\tendpointUrl: \"https://endpoint-3.workers.dev\",\n\t\t\t\t\t\t\t\t\tapiUrl: \"https://api.example.com/orders\",\n\t\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\t\tdescription: \"Fetch orders data\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype: \"thread\",\n\t\t\t\t\t\t\t\t\tcollectFromSteps: [1, 2, 3],\n\t\t\t\t\t\t\t\t\toutputFormat: \"json\",\n\t\t\t\t\t\t\t\t\tdescription: \"Collect all API responses\",\n\t\t\t\t\t\t\t\t\tcompletionCheck: {\n\t\t\t\t\t\t\t\t\t\tmode: \"deterministic\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"Analyze the collected data and provide insights on user behavior, popular products, and order patterns\",\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tprovider: \"openai\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\trouterExample: {\n\t\t\t\t\t\t\tdescription: \"Router instruction allows LLM to decide which endpoint to call based on context\",\n\t\t\t\t\t\t\tcontext: \"User is asking about the weather for hiking this weekend\",\n\t\t\t\t\t\t\tinstructions: [\n\t\t\t\t\t\t\t\t\"Analyze the user's question and identify the main topic and intent\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype: \"router\",\n\t\t\t\t\t\t\t\t\tdescription: \"Select the most appropriate data source\",\n\t\t\t\t\t\t\t\t\tevaluationPrompt: \"Based on the analysis, which data source would best answer this query?\",\n\t\t\t\t\t\t\t\t\toptions: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tid: \"weather\",\n\t\t\t\t\t\t\t\t\t\t\tname: \"Weather API\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Weather forecasts, outdoor conditions, temperature data\",\n\t\t\t\t\t\t\t\t\t\t\tendpoint: {\n\t\t\t\t\t\t\t\t\t\t\t\tendpointUrl: \"https://endpoint-1.workers.dev\",\n\t\t\t\t\t\t\t\t\t\t\t\tapiUrl: \"https://endpoint-1.workers.dev/mock/weather\",\n\t\t\t\t\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tid: \"news\",\n\t\t\t\t\t\t\t\t\t\t\tname: \"News API\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Current events, trending topics, news articles\",\n\t\t\t\t\t\t\t\t\t\t\tendpoint: {\n\t\t\t\t\t\t\t\t\t\t\t\tendpointUrl: \"https://endpoint-2.workers.dev\",\n\t\t\t\t\t\t\t\t\t\t\t\tapiUrl: \"https://endpoint-2.workers.dev/mock/news\",\n\t\t\t\t\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tid: \"finance\",\n\t\t\t\t\t\t\t\t\t\t\tname: \"Finance API\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Stock prices, market data, financial news\",\n\t\t\t\t\t\t\t\t\t\t\tendpoint: {\n\t\t\t\t\t\t\t\t\t\t\t\tendpointUrl: \"https://endpoint-3.workers.dev\",\n\t\t\t\t\t\t\t\t\t\t\t\tapiUrl: \"https://endpoint-3.workers.dev/mock/finance\",\n\t\t\t\t\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tdefaultOption: \"weather\",\n\t\t\t\t\t\t\t\t\tretries: 3,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"Using the data retrieved, provide a helpful response to the user's question\",\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tprovider: \"openai\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tendpointExample: {\n\t\t\t\t\t\t\tcontext: \"Fetch data from external API\",\n\t\t\t\t\t\t\tinstructions: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype: \"endpoint\",\n\t\t\t\t\t\t\t\t\tendpointUrl: \"https://endpoint-1.your-subdomain.workers.dev\",\n\t\t\t\t\t\t\t\t\tapiUrl: \"https://api.example.com/data\",\n\t\t\t\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\t\t\t\tretries: 3,\n\t\t\t\t\t\t\t\t\tretryDelay: 1000,\n\t\t\t\t\t\t\t\t\ttimeout: 30000,\n\t\t\t\t\t\t\t\t\tdescription: \"Fetch user data from external API\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"Process the fetched data using LLM\",\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tprovider: \"openai\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\texample: {\n\t\t\t\t\t\t\tcontext: \"The quick brown fox jumps over the lazy dog.\",\n\t\t\t\t\t\t\tinstructions: [\n\t\t\t\t\t\t\t\t\"Summarize this text in one sentence.\",\n\t\t\t\t\t\t\t\t\"Rewrite the summary to be more formal.\",\n\t\t\t\t\t\t\t\t\"Translate to Spanish.\",\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tprovider: \"openai\",\n\t\t\t\t\t\t\tmodel: \"gpt-5-nano\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tconditionalExample: {\n\t\t\t\t\t\t\tcontext: \"Analyze this code: function test() { return true; }\",\n\t\t\t\t\t\t\tinstructions: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinstruction: \"Check if the code contains a function definition\",\n\t\t\t\t\t\t\t\t\tcondition: {\n\t\t\t\t\t\t\t\t\t\tevaluateAfterStep: 1,\n\t\t\t\t\t\t\t\t\t\texpression: \"result contains 'function'\",\n\t\t\t\t\t\t\t\t\t\tifTrue: [1], // Execute step 1 (index 1) if true\n\t\t\t\t\t\t\t\t\t\tifFalse: [2], // Execute step 2 (index 2) if false\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"Extract the function name\",\n\t\t\t\t\t\t\t\t\"List all parameters\",\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tprovider: \"openai\",\n\t\t\t\t\t\t\tmodel: \"gpt-5-nano\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tanthropicExample: {\n\t\t\t\t\t\t\tcontext: \"The quick brown fox jumps over the lazy dog.\",\n\t\t\t\t\t\t\tinstructions: [\n\t\t\t\t\t\t\t\t\"Summarize this text in one sentence.\",\n\t\t\t\t\t\t\t\t\"Rewrite the summary to be more formal.\",\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tprovider: \"anthropic\",\n\t\t\t\t\t\t\tmodel: \"claude-haiku-4-5\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlegacyExample: {\n\t\t\t\t\t\t\tcontext: \"The quick brown fox jumps over the lazy dog.\",\n\t\t\t\t\t\t\tfirstInstruction: \"Summarize this text in one sentence.\",\n\t\t\t\t\t\t\tsecondInstruction: \"Rewrite the summary to be more formal.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"POST /batch\": {\n\t\t\t\t\t\tdescription: \"Create multiple workflow instances concurrently\",\n\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\tcount: \"number (1-20) - Number of workflow instances to create\",\n\t\t\t\t\t\t\tcontext: \"string - The initial context to process\",\n\t\t\t\t\t\t\tinstructions: \"string[] | ConditionalInstruction[] - Array of instructions\",\n\t\t\t\t\t\t\tprovider: \"string (optional) - AI provider: 'openai' or 'anthropic'\",\n\t\t\t\t\t\t\tmodel: \"string (optional) - Model name\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\texample: {\n\t\t\t\t\t\t\tcount: 3,\n\t\t\t\t\t\t\tcontext: \"Test concurrent processing\",\n\t\t\t\t\t\t\tinstructions: [\"Process this\", \"Then process that\"],\n\t\t\t\t\t\t\tprovider: \"openai\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"GET /?instanceId=<id>\": {\n\t\t\t\t\t\tdescription: \"Get the status of an existing workflow instance\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tconcurrency: {\n\t\t\t\t\tnote: \"Multiple workflow instances can run concurrently. Each POST creates a new isolated instance.\",\n\t\t\t\t\tbatchEndpoint: \"Use POST /batch to create multiple instances at once (up to 20).\",\n\t\t\t\t},\n\t\t\t\tproviders: {\n\t\t\t\t\topenai: {\n\t\t\t\t\t\tdefaultModel: \"gpt-5-nano\",\n\t\t\t\t\t\tmodels: [\"gpt-5-nano\", \"gpt-4o-mini\"],\n\t\t\t\t\t\tapiKeyEnv: \"OPENAI_API_KEY\",\n\t\t\t\t\t},\n\t\t\t\t\tanthropic: {\n\t\t\t\t\t\tdefaultModel: \"claude-haiku-4-5\",\n\t\t\t\t\t\tmodels: [\"claude-haiku-4-5\"],\n\t\t\t\t\t\tapiKeyEnv: \"ANTHROPIC_API_KEY\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t},\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/src/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/.wrangler/tmp/bundle-WhCXnJ/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/.wrangler/tmp/bundle-WhCXnJ/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/objsinc-macair-00/objs-colleague/jimmy/lab/workflow-station/workflow-engine/.wrangler/tmp/bundle-WhCXnJ/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["context"]
}
